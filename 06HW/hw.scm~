(define break #f)
(call-with-current-continuation
 (lambda (k) (set! break k)))


(define (make-source sequence . end)
  (define xs (cond ((list? sequence) sequence)
                   ((vector? sequence) (vector->list sequence))
                   ((string? sequence) (string->list sequence))))
  (define eot (if (pair? end)
                  (car end)
                  #f)) 
  (list->vector (cons 2 (cons eot xs))))

(define (peek vs)
  (if (= (vector-ref vs 0) (vector-length vs))
      (vector-ref vs 1)
      (vector-ref vs (vector-ref vs 0))))

(define (next vs)
  (if (= (vector-ref vs 0) (vector-length vs))
      (vector-ref vs 1)
      (begin
        (vector-set! vs 0 (+ 1 (vector-ref vs 0))) 
        (vector-ref vs (- (vector-ref vs 0) 1)))))

(define (space? sym) 
  (or (eq? #\tab sym)
      (eq? #\space sym)
      (eq? #\newline sym)))

(define (int? num)
  (or (eq? #\1 num)
      (eq? #\2 num)
      (eq? #\3 num)
      (eq? #\4 num)
      (eq? #\5 num)
      (eq? #\6 num)
      (eq? #\7 num)
      (eq? #\8 num)
      (eq? #\9 num)
      (eq? #\0 num)
      (eq? #\. num)))

(define (bracket? sym)
  (or (eq? #\( sym)
      (eq? #\) sym)))

(define (op? sym)
  (or (eq? #\- sym)
      (eq? #\+ sym)
      (eq? #\* sym)
      (eq? #\/ sym)
      (eq? #\^ sym)))
(define (AddOp? sym)
  (or (eq? #\- sym)
      (eq? #\+ sym)))
(define (MulOp? sym)
  (or (eq? #\/ sym)
      (eq? #\* sym)))


;Lexer
(define (tokenize str)
  (define src (make-source str))
  (define (lexer xs var num)
    (cond ((and (pair? num) (or (not (peek src)) (not (int? (peek src)))))
           (lexer (cons (string->number (list->string (reverse num))) xs) var '()))
          ((and (pair? var) (or (not (peek src)) (not (char-alphabetic? (peek src)))))
           (lexer (cons (string->symbol (list->string (reverse var))) xs) '() num))
          ((not (peek src)) (reverse xs))
          ((char-alphabetic? (peek src))
           (lexer xs (cons (next src) var) num))
          ((int? (peek src))
           (lexer xs var (cons (next src) num)))
          ((bracket? (peek src))
           (lexer (cons (string (next src)) xs) var num))
          ((op? (peek src))
           (lexer (cons (string->symbol (string (next src))) xs) var num))
          ((space? (peek src))
           (begin
             (next src)
             (lexer xs var num)))
          (else (break #f))))
  (lexer '() '() '()))

;Expr    ::= Term Expr' .
;Expr'   ::= AddOp Term Expr' | .
;Term    ::= Factor Term' .
;Term'   ::= MulOp Factor Term' | .
;Factor  ::= Power Factor' .
;Factor' ::= PowOp Power Factor' | .
;Power   ::= value | "(" Expr ")" | unaryMinus Power .

;Parser
(define (parse tokens)
  (let* ((src (make-source tokens))
         (tree (parse-expr src)))
    `( ,tree)))

;Expr    ::= Term Expr' .
(define (parse-expr src)
  (let* ((term (parse-term src))
         (exprs (parse-exprs src)))
    (if (null? exprs)
        term
        `(,term ,@exprs))))
Ñ‹
;Expr'   ::= AddOp Term Expr' | .
(define (parse-exprs src)
  (if (not (peek src))
      '()
      (if (AddOp? (peek src))
          (let* ((op (next src))
                 (term (parse-term src))
                 (exprs (parse-exprs src)))
            (if (null? exprs)
                (list op term)
                (list op term exprs))))))
 ;Term    ::= Factor Term' .               
(define (parse-term src)
  (let* ((factor (parse-factor src))
         (terms (parse-terms src)))
    (if (null? terms)
        factor
        (list factor terms))))
;Term'   ::= MulOp Factor Term' | .
(define (parse-terms src)
  (if (not (peek src))
      '()
      (if (MulOp? (peek src))
          (let* ((op (next src))
                 (factor (parse-factor src))
                 (terms (parse-terms src)))
            (if (null? terms)
                (list op factor)
                (list op factor terms))))))
;Factor  ::= Power Factor' .
(define (parse-factor src)
  (let* ((power (parse-power src))
         (factors (parse-factors src)))
    (if (null? factors)
        (list power factors)
        power)))
;Factor' ::= PowOp Power Factor' | .
(define (parse-factors src)
  (if (not (peek src))
      '()
      (if (eq? (peek src) '^)
          (let* ((op (next src))
                 (power (parse-power src))
                 (factors (parse-factors src)))
            (if (null? factors)
                (list op power)
                (list op power factors))))))
;Power   ::= value | "(" Expr ")" | unaryMinus Power .
(define (parse-power src)
  (cond ((eq? (peek src) '-)
         (let* ((minus (next src))
                (power (parse-power src)))
           (list minus (parse-power src))))
        ((eq? (peek src) "(" )
         (begin
           (let* ((f (next src))
                  (expr (parse-expr src))
                  (l (next src)))
             expr)))
        ((or (number? (peek src))
             (and (symbol? (peek src))
                  (not (AddOp? (peek src)))
                  (not (MulOp? (peek src)))))
         (next src))
        (else 'lol)))