;Expr    ::= Term Expr' .
;Expr'   ::= AddOp Term Expr' | .
;Term    ::= Factor Term' .
;Term'   ::= MulOp Factor Term' | .
;Factor  ::= Power Factor' .
;Factor' ::= PowOp Power Factor' | .
;Power   ::= value | "(" Expr ")" | unaryMinus Power .

(load "debug.scm")

(define (make-source sequence . end)
  (define xs (cond ((list? sequence) sequence)
                   ((vector? sequence) (vector->list sequence))
                   ((string? sequence) (string->list sequence))))
  (define eot (if (pair? end)
                  (car end)
                  #f)) 
  (list->vector (cons 2 (cons eot xs))))

(define (peek vs)
  (if (= (vector-ref vs 0) (vector-length vs))
      (vector-ref vs 1)
      (vector-ref vs (vector-ref vs 0))))

(define (next vs)
  (if (= (vector-ref vs 0) (vector-length vs))
      (vector-ref vs 1)
      (begin
        (vector-set! vs 0 (+ 1 (vector-ref vs 0))) 
        (vector-ref vs (- (vector-ref vs 0) 1)))))

(define (AddOp? sym)
  (or (eq? '- sym)
      (eq? '+ sym)))
(define (MulOp? sym)
  (or (eq? '/ sym)
      (eq? '* sym)))

;Parser
(define (parse tokens)
  (let* ((src (make-source tokens))
         (tree (parse-expr src)))
    `( ,@tree)))

;Expr    ::= Term Expr' .
(define src '())
(define (parse-expr src)
  (let* ((term (parse-term src))
         (exprs (parse-exprs src)))
    (if (null? exprs)
        term
        `(,@term ,@exprs))))
;Expr'   ::= AddOp Term Expr' | .
(define (parse-exprs src)
  (if (not (peek src))
      '()
      (if (AddOp? (peek src))
          (let* ((op (next src))
                 (term (parse-term src))
                 (exprs (parse-exprs src)))
            (if (null? exprs)
                `(,op ,@term)
                `(,op ,@term ,@exprs)))
          (begin (write 'lol1)
                 (write src)))))
 ;Term    ::= Factor Term' .               
(define (parse-term src)
  (let* ((factor (parse-factor src))
         (terms (parse-terms src)))
    (if (null? terms)
        factor
        `(,@factor ,@terms))))
;Term'   ::= MulOp Factor Term' | .
(define (parse-terms src)
  (if (not (peek src))
      '()
      (if (MulOp? (peek src))
          (let* ((op (next src))
                 (factor (parse-factor src))
                 (terms (parse-terms src)))
            (if (null? terms)
                `(,op ,@factor)
                `(,op ,@factor ,@terms)))
          (begin (write 'lol2)
                 (write src)))))
;Factor  ::= Power Factor' .
(define (parse-factor src)
  (let* ((power (parse-power src))
         (factors (parse-factors src)))
    (if (null? factors)
        `(,@power ,@factors)
        power)))
;Factor' ::= PowOp Power Factor' | .
(define (parse-factors src)
  (if (not (peek src))
      '()
      (if (eq? (peek src) '^)
          (let* ((op (next src))
                 (power (parse-power src))
                 (factors (parse-factors src)))
            (if (null? factors)
                `(,op ,@power)
                `(,op ,@power ,@factors)))
          (begin (write 'lol3)
                 (write src)))))

(define (parse-factor src)
    (let ((res (parse-power src)))
      (if (equal? (peek src) '^)
          (list res (next src) (parse-factor src))
          res)))
;Power   ::= value | "(" Expr ")" | unaryMinus Power .
(define (parse-power src)
  (cond ((equal? (peek src) '-)
         (let* ((minus (next src))
                (power (parse-power src)))
           (list minus (parse-power src))))
        ((equal? (peek src) "(" )
         (begin
           (let* ((f (next src))
                  (expr (parse-expr src))
                  (l (next src)))
             (list expr))))
        ((or (number? (peek src))
             (and (symbol? (peek src))
                  (not (AddOp? (peek src)))
                  (not (MulOp? (peek src)))))
         (next src))
        (else 'lol)))