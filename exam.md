# Ответы к экзамену 2020

https://github.com/bmstu-iu9/scheme-labs/blob/master/exam.md

## 1. Понятие о данных

**Данные** - представление понятий, фактов, инструкций в форме, приемлемой для общения, интерпретации и обработки человеком или автоматическими средствами.

## 2. Понятие программы, алгоритма

**Алгоритм** - конечная совокупность точно заданных правил решения произвольного класса задач или набор инструкций, описывающих порядок действий исполнителя для решения некоторых задач.

**Свойства алгоритма**
 - дискретность (деление на части)
 - детерминированность (результат определён входными данными, нет undefined behavior)
 - понятность
 - завершаемость (конечен)
 - массовость (пригоден для решения *класса* задач)
 - результативность

## 3. Понятия типа данных, системы типов языка программирования, типизации.

**Тип данных** - множество значений, множество операций над ним и способ хранения (машинное представление).

**Система типов языка программирования** - набор правил, определяющих свойства конструкций языка: переменных, значений, выражений и т.д.

**Типизация** - контроль типов в ЯП. Определения типа может быть явным (Си) или неявным (Python, Scheme).

## 4. Важнейшие парадигмы программирования и их отличительные черты.

1) **Императивное программирование** - процесс вычислений описывается как последовательность инструкций, изменяющих состояние программы.

2) *Процедурное программирование* - относится к императивному. Процесс вычислений оформляется как набор отдельных именованных подпрограмм, к которым можно обращаться для выполнения операций.

3) *Структурное программирование* - относится к императивному. Процесс вычислений оформляется как иерархическая структура блоков. Любая программа строится из трех базовых управляющих конструкций: последовательность, ветвление, цикл. Не используется goto.

4) *Объектно-ориентированное программирование* - относится к императивному. Процесс вычислений оформляется как набор отдельных именованных описанных объектов.

5) **Декларативное программирование** - процесс вычислений оформляется как описание цели программы/логики вычислений или отношений между объектами без явного указания последовательности действий.

6) *Функциональное программирование* - парадигма программирования, в которой вычисления рассматриваются как вычисления значений функций.

7) *Логическое программирование* - парадигма программирования, в которой вычисления рассматриваются как обработка информации на основе заданных фактов и правил вывода.

7) **Метапрограммирование** - вид программирования, в котором созданные программы способны порождать другие программы как результат своей работы, либо программ, которые меняют сами себя во время выполнения.


![таблица](https://i.ibb.co/S6CS8Ky/Mind-Map.jpg)

## 5. Каким образом в язык программирования с динамической типизацией можно ввести новый тип данных? Приведите примеры.

Для этого достаточно придумать способ хранения данных нового типа, написать соответствующие процедуры/методы для выполнения необходимых операций.

## 6. Понятие абстрактного типа данных. Примеры.

**Абстрактный тип данных** ­- тип данных, который рассматривается независимо от контекста и реализации в программе. Напр. стек, очередь, ассоциативный массив.

## 7. Функции (процедуры) высшего порядка в языках программирования высокого уровня.

**Функция высшего порядка** - функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.

## 8.Способы организации повторяющихся вычислений в языках программирования высокого уровня.

Цикл, рекурсия.

## 9. Мемоизация результатов вычислений.

**Мемоизация** - сохранения результатов выполнения функции для предотвращения повторных вычислений. Один из способов оптимизации, применяемый для увеличения выполнения скорости компьютерных программ.

```
# мемоизация функции факториала в Scheme

(define (memoized-factorial n)
  (let ((memory '())
        (define (factorial n)
          (let ((memoized (assq n memory))
                (if (momoized)
                    (cadr memoized)
                    (let ((new-val (if (< n 2)
                                       1
                                       (* n (memoized-factorial (- n 1))))))
                      (set! memory (cons (list n new-val) memory)) new-val))))))))
```

## 10. Нестрогие и отложенные вычисления

Нестрогие вычисления означают, что аргументы не вычисляются до тех пор, пока их значение не используется в теле функции. Пример: *or* и *and* в Scheme.

Отложенные (ленивые) вычисления - вычисления, откладывающиеся до тех пор, пока пока не понадобится их результат. 

В Scheme Отложенные вычисления можно организовать с помощью delay и force.
 
*Прим.: нестрогие вычисления относятся к семантике, т.е. к математическому значению выражения и не имеют прямого отношения к компьютеру. В то время как ленивые вычисления относятся к "операционному" поведению на реальном компьютере. Ленивые вычисления порождаются нестрогой семантикой.*

Примеры: 

```
(define delayed (delay (+ 23 22)))
delayed ; #<promise>
(force delayed) ; 45
; delay сохраняет выражения в объект #<promise>, force выполняет #<promise>
```

## 11. Способы реализации языка программирования высокого уровня.

ЯП высокого уровня могут быть реализованы как компилируемые или интерпретируемые.

## 12. Компилятор и интерпретатор: определение, основные функциональные элементы.

**Компилятор** - программа, выполняющая компиляцию
**Интерпретатор** - программа, выполняющая пооператорный (покомандный) анализ, обрабатывающая, и тут же выполняющая программу.

**Компиляция** - трансляция программы, составленной на ЯП высокого уровня в эквивалентную программу на низкоуровневом языке, близком к машинному коду.

**Процесс компиляции:**

1) Лексический анализ (им занимается лексер/сканер) - преобразование исходной последовательности символов в последовательность лексем и токенов. Лексема - последовательность допустимых сиволов ЯП, имеющих смысл для транслятора. Это минимальные значимые единицы кода программы.

2) Синтаксический анализ (им занимается синтаксический анализатор/парсер) - процесс сопоставления линейной последовательности лексем и его формальной грамматики. Это разбор исходной строки символов в соответствии с правилами формальной грамматики в дерево разбора.

3) Семантический анализ - анализ вычислений. Обработка дерева разбора для установления смысла: напр., привязка идентификаторов к их декларациям, типам, определение типов выражений и т.д.

4) Оптимизация (необязательный этап) - удаление излишних конструкций для упрощения кода с сохранением его смысла.

5) Генерация кода - создание машшиного кода или байт-кода.

**Байт­код** -­ промежуточное представление, в которое может быть переведена компьютерная программа. Это компактное представление программы, уже прошедшей синтаксический и семантический анализ.

## 13. Лексический анализатор: назначение, входные данные, выходные данные, принцип реализации.

Назначение - преобразование исходной последовательности символов в последовательность токенов.

Входные данные - последовательность символов программы.

Выходные данные - последовательность токенов.

Распознавание лексем в контексте грамматики обычно производится путём их идентификации (или классификации) согласно идентификаторам (или классам) токенов, определяемых грамматикой языка. При этом любая последовательность символов входного потока (лексема), которая согласно грамматике не может быть идентифицирована как токен языка, обычно рассматривается как специальный токен­-ошибка.
Каждый токен можно представить в виде структуры, содержащей идентификатор токена (или идентификатор класса токена) и, если нужно, последовательность символов лексемы, выделенной из входного потока (строку, число и т. д.).

## 14. Синтаксический анализатор: назначение, входные данные, выходные данные.

Назначение - построение дерева разбора по последовательности лексем/токенов согласно заданной формальной граматике.

Входные данные - последовательность лексем/токенов.

Выходные данные - дерево разбора.


## 15. Формальная грамматика: терминальные символы, нетерминальные символы, правила, аксиома.

**Формальная грамматика** — это способ описания синтаксиса языков программирования.

**Терминальные символы** - символы алфавита, из которых строятся инструкции языка программирования. Для стадии лексческого анализа терминальные символы - литеры (characters) текста программы. Для стадии синтаксического анализа терминальные символы - токены.

**Нетерминальные символы** - символы, которые раскрываются согласно правилам грамматики.

**Правила грамматики** - правила, описывающие как в строке символов (терминальных и нетерминальных) раскрываются нетерминальные символы.

**Аксиома грамматики** - нетерминальный символ, выбранный в качестве стартового.

## 16. БНФ и синтаксические диаграммы.

**Форма Бекуса-Наура** - способ описания грамматики языка, где правила имеют вид:
<нетерминал> ::= <альтернатива> | ... | <альтернатива>

Нетерминалы записываются в угловых скобках, терминальные символы записываются или сами собой (для знаков операций, например), или словами БОЛЬШИМИ БУКВАМИ. Альтернативные варианты разделяются знаками `|`.

Пример:

    <Выражение> ::= <Слагаемое> | <Выражение> + <Слагаемое>
    <Слагаемое> ::= <Множитель> | <Слагаемое> * <Множитель>
    <Множитель> ::= ЧИСЛО | ( <Выражение> )

Впервые была использована при описании языка Алгол-60.

**Синтаксические диаграммы** - графический способ описания языка. Впервые были использованы Николасом Виртом при описании грамматики языка Паскаль в 1973.

## 17. LL(1)-грамматики: особенности и их использование.

LL(1)-грамматики - грамматики, в которых можно определить правило для раскрытие нетерминала по первому символу входной цепочки.

Пример: **не** LL(1)-грамматики:

    E → T | E + T
    T → F | T * F
    F → n | ( E )

Если имеем строку `n * n * n + n + n` и нетерминал `E`, то мы не знаем, по какому
правилу нужно раскрывать `E`. Поскольку в начале строки может быть сколько
угодно сомножителей, в общем случае, чтобы выбрать правило раскрытия для `E`
(т.е. `E → T` или `E → E + T`), нужно прочитать неизвестное количество входных
знаков. А для LL(k)-грамматики k должно быть конечно и фиксировано.

Пример: LL(1)-грамматика для тех же арифметических выражений:

    E → T E′
    E′ → ε | + T E′
    T → F T′
    T′ → ε | * F T′
    F → n | ( E )

Грамматика **не** LL(1) если разные правила начинаются с одинаковых символов:

    A → x a | x b

Грамматика **не** LL(1), если в правилах имеем т.н. левую рекурсию:

    A → x | A y

Преимущество LL(1)-грамматик — для них сравнительно легко написать синтаксический анализатор методом рекурсивного спуска.

## 18. Принцип построения лексического анализатора.

Анализатор проходит по тексту программы и в соответствии с алфавитом разбивает её на токены, т.е. определяет границы лексем и сохраняет информацию о них.

## 19. Принцип построения нисходящего синтаксического анализатора, осуществляющего разбор методом рекурсивного спуска.

**Метод рекурсивного спуска** — способ написания синтаксических анализаторов для LL(1)-грамматик на алгоритмических языках программирования. Для каждого нетерминала грамматики записывается процедура, тело которой выводится из правил для данного нетерминала.

Построенный синтаксический анализатор выдаёт сообщение о принадлежности входной строки к заданному языку.

Написание синтаксического анализатора состоит из этапов:

1. Составление LL(1)-грамматики для данного языка программирования.
2. Формальное выведение парсера из правил грамматики. Парсер либо молча принимает
   строку, либо выводит сообщение об ошибке.
3. Наполнение парсера семантическими действиями — построение дерева разбора,
   выполнение проверок на корректность типов операций, возможно даже, вычисление результата в процессе разбора.

## 20. Основные понятие ООП
\-

## 21. Модульное тестирование (юнит-тестирование), разработка через тестирование.

**Модульный тест** - тест, проверяющий работу малой части программы: функции, процедуры, класса, метода класса. Модульный тест самопроверяемый, выполнятеся быстро.

**Разработка через тестирование**
Выполняется короткими циклами длительностью ~1 минута.

1. Написание теста для неготовой функциональности
2. Написание функциональности, позволяющей пройти новому тесту. Теперь все тесты должны проходить.
3. Рефакторинг - улучшение внутренней структуры программы с точным сохранением внешнего поведения. Тесты должны по-прежнему проходить.

## 22. Способы разбора и вычисления значения арифметического выражения, записанного в инфиксной нотации, с учетом приоритетов операций и скобок. (В Scheme?)

Арифметическое выражение в инфиксной нотации разбирается непосредственно во время стадии синтаксического анализа.

#### Осуществляется лексический анализ: формируется последовательность из токенов:
1. имена переменных и знаки операций переходят в символические константы.
2. числа переходят в числовые константы.
3. скобки - в строки `"("` и `")"`.

#### Осуществляется синтаксический анализ согласно следующей грамматике:
```
<expression> ::= <term> <expression'> .
<expression'> ::= <add_operation> <term> <expression'> | e .
<term> ::= <factor> <term'> .
<term'> ::= <mult_operation> <factor> <term'> | e .
<factor> ::= <power> <factor'> .
<factor'> ::= <power_operation> <power> <factor'> | e .
<power> ::= <value> | "(" <expression> ")" | <unary_minus> <power> .
```

Терминалы - `<value>`, скобки и знаки операций

Разбор осуществляется методом рекурсивного спуска.

## 23. Основные постулаты языков программирования семейства Lisp.

1) Единство кода и данных.
2) Всё есть список.
3) Выражения являются списками, операция указывается в первом элементе.
4) Все выражения вычисляют значения.

## 24. Общая характеристика языка Scheme.

```
<term> ::= <atom> | <list>
<list> ::= (<terms>)
<terms> ::= e | <term> <terms>
<atom> ::= <variable> | <number> | <symbol> | <character> | <string> ...
```

**Scheme** - функциональный язык программирования, один из двух наиболее распространённых диалектов языка Lisp.

## 25. Типизация и система типов языка Scheme.

Система типов - строгая, динамическая. Типизация неявная.

## 26. Способы определения процедуры в языке Scheme. Формальные и фактические аргументы, применение к аргументам, возвращаемое значение.

Определение процедуры:
```
(define (<function name> <formal arguments>)
    <body>)
```
Вызов процедуры:
```
(<function name> <real arguments>)
; или
(apply <function name> <real arguments>)
```

## 27. Простые типы языка Scheme и основные операции над ними.

- Числа
  - Целые
  - Вещественные
  - Рациональные
  - Комплексные
    ```
    ; предикаты
    (number? 5) => #t
    (number? 1.234) => #t
    (complex? 1+i) => #t
    (rational? 1+i) => #f

    ; операции сравнения: <, >, <=, >=, =

    ; математические операции: +, -, *, /

    ; математические функции: expt, max, min, abs, sqrt
    ```
- Символы (цитаты)
  ```
  (symbol? 'abc) => #t
  (symbol? 5) => #f
  (symbol? #\c) => #f
  ; не чувствительны к регистру
  (equal? 'Abc 'abc) => #t
  ``` 
- Логический
  ```
  (boolean? #t) => #t
  (not #f) => #t
  (not #t) => #f
  (and #f #t) => #f
  ``` 
- Characters
  ```
  (char? #\c) => #t
  (char? 1) => #f
  
  (char=? #\a #\a) => #t
  (char<? #\a #\b) => #t
  (char>=? #\a #\b) => #f

  ; ci = case-insensetive
  (char-ci=? #\a #\A) => #t

  (char-downcase #\A) => #\a
  (char-upcase #\a) => #\A
  ```

## 28. Составные типы языка Scheme и основные операции над ними.

- Строки 
    ```
    ; последовательности, состоящие из characters

    (string? "abc") => #t

    (string #\a #\b #\c)
    (make-string <length> <char>)
    (define line "abacaba xyz")

    (string-ref line 0) => #\a

    (string-append line "qwerty") => "abacaba xyz qwerty"

    (string-set! line 0 #\b) => "bbacaba"

    (string-length "abc") => 3

    ; доступны операции сравнения по символу как и с character, так же с case-insensitive
    (substring line 8 11) => "xyz"  
    ```
- Векторы
  ```
  ; последовательности из каких-либо объектов
  (vector? #(1 "abc" 'abc "\T)) => #t
  (vector 0 1 2 3 4) => #(0 1 2 3 4)

  (define v (make-vector <length> <element>))

  ; процедуры vector-ref и vector-set! обращаются к элементам и изменяют их.
  ``` 

- Точечные пары и списки
  ```
  Точечная пара получается путём соединения двух любых произвольных значений в упорядоченную пару. Первый элемент называется car, второй - cdr, а процедура объединения - cons. Точечные пары нужно указывать самостоятельно с помощью цитирования.

  '(1 . #t) => (1 . #t)
  (pair? '(1 . #t)) => #t
  (define x (cons 1 #t))
  (car x) => 1
  (cdr x) => #t

  Для изменения значения можно использовать процедуры set-car! и set-cdr!
  (set-car! x 2)
  (set-cdr! x #f)
  x => (2 . #f)

  Точечные пары могут содержать в себе другие пары
  (define y (cons (cons 1 2) 3))
  y => ((1 . 2) . 3)

  c...r - сокращение для уровня вложенности "хвоста" пары. Напр: cadr, caddr, cadddr

  list - процедура для создания списка. Принимает любое количество аргументов и возвращает список, содержащий их.

  (list 1 2 3 4) => (1 2 3 4)
  '(1 2 3 4) => (1 2 3 4) ; цитирование подходит, когда не нужно вычислять реальные аргументы

  обращение по индексу, получение списка без первых k элементов:
  (define l (list 1 2 3 4))
  (list-ref l 0) => 1
  (list-tail l 1) => (2 3 4)

  предикаты
  (pair? '(1 . 2)) => #t
  (pair? '(1 2)) => #t
  (pair? '()) => #f
  (list? '()) => #t
  (null? '()) => #t
  (list? '(1 2)) => #t
  (list? '(1 . 2)) => #f

  ```
- Преобразование типов данных
  ```
  string->list
  list->string
  vector->list
  list->vector
  number->string
  string->number
  symbol->string
  string->symbol
  char->integer ; возвращает код по таблице ascii
  integer->char ; возвращает символ по таблице ascii
  ```

## 29. Символьный тип в языке Scheme и его применение.
- Characters
  ```
  (char? #\c) => #t
  (char? 1) => #f
  
  (char=? #\a #\a) => #t
  (char<? #\a #\b) => #t
  (char>=? #\a #\b) => #f

  ; ci = case-insensetive
  (char-ci=? #\a #\A) => #t

  (char-downcase #\A) => #\a
  (char-upcase #\a) => #\A

  (char->integer)
  (integer->char)
  ```
- Symbol
    ```
    (symbol? 'abc) => #t
    (symbol? 5) => #f
    (symbol? #\c) => #f
    ; не чувствительны к регистру
    (equal? 'Abc 'abc) => #t
    (symbol? 'foo) ; ===> #t
    (symbol? (car '(a b))) ; ===> #t
    (symbol? "bar") ; ===> #f
    (symbol? 'nil) ; ===> #t
    (symbol? '()) ; ===> #f
    (symbol? #f) ; ===> #f

    ; основные процедуры
    symbol->string
    string->symbol
    ```

## 30. Применение процедур (функций) высшего порядка для обработки списков на языке Scheme.

**Функции высших порядков** ­­- функции, которые могут принимать в качестве
аргументов и возвращать другие функции. Математики такую функцию чаще называют
оператором, например, оператор взятия производной или оператор интегрирования.

Функции высших порядков позволяют использовать карринг (каррирование) ­­- преобразование функции от
пары аргументов в функцию, берущую свои аргументы по одному. Это преобразование
получило свое название в честь Х. Карри.

```
(define a (list 1 2 3))
(define b (list -11 12 -13))

(map abs b) => (11 12 13) ; применяет процедуру к каждому элементу в списке, возвращает список изменённых элементов
(apply * a) => 6 ; применяет процедуру к элементам списка, как будто они являются её аргументами
```