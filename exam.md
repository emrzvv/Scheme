# Подготовка к экзамену 2020

https://github.com/bmstu-iu9/scheme-labs/blob/master/exam.md

## 1. Понятие о данных

**Данные** - представление понятий, фактов, инструкций в форме, приемлемой для общения, интерпретации и обработки человеком или автоматическими средствами.

## 2. Понятие программы, алгоритма

**Алгоритм** - конечная совокупность точно заданных правил решения произвольного класса задач или набор инструкций, описывающих порядок действий исполнителя для решения некоторых задач.

**Свойства алгоритма**
 - дискретность (деление на части)
 - детерминированность (результат определён входными данными, нет undefined behavior)
 - понятность
 - завершаемость (конечен)
 - массовость (пригоден для решения *класса* задач)
 - результативность

## 3. Понятия типа данных, системы типов языка программирования, типизации.

**Тип данных** - множество значений, множество операций над ним и способ хранения (машинное представление).

**Система типов языка программирования** - набор правил, определяющих свойства конструкций языка: переменных, значений, выражений и т.д.

**Типизация** - контроль типов в ЯП. Определения типа может быть явным (Си) или неявным (Python, Scheme).

## 4. Важнейшие парадигмы программирования и их отличительные черты.

1) **Императивное программирование** - процесс вычислений описывается как последовательность инструкций, изменяющих состояние программы.

2) *Процедурное программирование* - относится к императивному. Процесс вычислений оформляется как набор отдельных именованных подпрограмм, к которым можно обращаться для выполнения операций.

3) *Структурное программирование* - относится к императивному. Процесс вычислений оформляется как иерархическая структура блоков. Любая программа строится из трех базовых управляющих конструкций: последовательность, ветвление, цикл. Не используется goto.

4) *Объектно-ориентированное программирование* - относится к императивному. Процесс вычислений оформляется как набор отдельных именованных описанных объектов.

5) **Декларативное программирование** - процесс вычислений оформляется как описание цели программы/логики вычислений или отношений между объектами без явного указания последовательности действий.

6) *Функциональное программирование* - парадигма программирования, в которой вычисления рассматриваются как вычисления значений функций.

7) *Логическое программирование* - парадигма программирования, в которой вычисления рассматриваются как обработка информации на основе заданных фактов и правил вывода.

7) **Метапрограммирование** - вид программирования, в котором созданные программы способны порождать другие программы как результат своей работы, либо программ, которые меняют сами себя во время выполнения.


![таблица](https://i.ibb.co/S6CS8Ky/Mind-Map.jpg)

## 5. Каким образом в язык программирования с динамической типизацией можно ввести новый тип данных? Приведите примеры.

Для этого достаточно придумать способ хранения данных нового типа, написать соответствующие процедуры/методы для выполнения необходимых операций.

## 6. Понятие абстрактного типа данных. Примеры.

**Абстрактный тип данных** ­- тип данных, который рассматривается независимо от контекста и реализации в программе. Напр. стек, очередь, ассоциативный массив.

## 7. Функции (процедуры) высшего порядка в языках программирования высокого уровня.

**Функция высшего порядка** - функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.

## 8.Способы организации повторяющихся вычислений в языках программирования высокого уровня.

Цикл, рекурсия.

## 9. Мемоизация результатов вычислений.

**Мемоизация** - сохранения результатов выполнения функции для предотвращения повторных вычислений. Один из способов оптимизации, применяемый для увеличения выполнения скорости компьютерных программ.

```
# мемоизация функции факториала в Scheme

(define (memoized-factorial n)
  (let ((memory '())
        (define (factorial n)
          (let ((memoized (assq n memory))
                (if (momoized)
                    (cadr memoized)
                    (let ((new-val (if (< n 2)
                                       1
                                       (* n (memoized-factorial (- n 1))))))
                      (set! memory (cons (list n new-val) memory)) new-val))))))))
```

## 10. Нестрогие и отложенные вычисления

Нестрогие вычисления означают, что аргументы не вычисляются до тех пор, пока их значение не используется в теле функции. Пример: *or* и *and* в Scheme.

Отложенные (ленивые) вычисления - вычисления, откладывающиеся до тех пор, пока пока не понадобится их результат. 

В Scheme Отложенные вычисления можно организовать с помощью delay и force.
 
*Прим.: нестрогие вычисления относятся к семантике, т.е. к математическому значению выражения и не имеют прямого отношения к компьютеру. В то время как ленивые вычисления относятся к "операционному" поведению на реальном компьютере. Ленивые вычисления порождаются нестрогой семантикой.*

Примеры: 

```
(define delayed (delay (+ 23 22)))
delayed ; #<promise>
(force delayed) ; 45
; delay сохраняет выражения в объект #<promise>, force выполняет #<promise>
```

## 11. Способы реализации языка программирования высокого уровня.

ЯП высокого уровня могут быть реализованы как компилируемые или интерпретируемые.

## 12. Компилятор и интерпретатор: определение, основные функциональные элементы.

**Компилятор** - программа, выполняющая компиляцию
**Интерпретатор** - программа, выполняющая пооператорный (покомандный) анализ, обрабатывающая, и тут же выполняющая программу.

**Компиляция** - трансляция программы, составленной на ЯП высокого уровня в эквивалентную программу на низкоуровневом языке, близком к машинному коду.

**Процесс компиляции:**

1) Лексический анализ (им занимается лексер/сканер) - преобразование исходной последовательности символов в последовательность лексем и токенов. Лексема - последовательность допустимых сиволов ЯП, имеющих смысл для транслятора. Это минимальные значимые единицы кода программы.

2) Синтаксический анализ (им занимается синтаксический анализатор/парсер) - процесс сопоставления линейной последовательности лексем и его формальной грамматики. Это разбор исходной строки символов в соответствии с правилами формальной грамматики в дерево разбора.

3) Семантический анализ - анализ вычислений. Обработка дерева разбора для установления смысла: напр., привязка идентификаторов к их декларациям, типам, определение типов выражений и т.д.

4) Оптимизация (необязательный этап) - удаление излишних конструкций для упрощения кода с сохранением его смысла.

5) Генерация кода - создание машшиного кода или байт-кода.

**Байт­код** -­ промежуточное представление, в которое может быть переведена компьютерная программа. Это компактное представление программы, уже прошедшей синтаксический и семантический анализ.

## 13. Лексический анализатор: назначение, входные данные, выходные данные, принцип реализации.

Назначение - преобразование исходной последовательности символов в последовательность токенов.

Входные данные - последовательность символов программы.

Выходные данные - последовательность токенов.

Распознавание лексем в контексте грамматики обычно производится путём их идентификации (или классификации) согласно идентификаторам (или классам) токенов, определяемых грамматикой языка. При этом любая последовательность символов входного потока (лексема), которая согласно грамматике не может быть идентифицирована как токен языка, обычно рассматривается как специальный токен­-ошибка.
Каждый токен можно представить в виде структуры, содержащей идентификатор токена (или идентификатор класса токена) и, если нужно, последовательность символов лексемы, выделенной из входного потока (строку, число и т. д.).

## 14. Синтаксический анализатор: назначение, входные данные, выходные данные.

Назначение - построение дерева разбора по последовательности лексем/токенов согласно заданной формальной граматике.

Входные данные - последовательность лексем/токенов.

Выходные данные - дерево разбора.


## 15. Формальная грамматика: терминальные символы, нетерминальные символы, правила, аксиома.

**Формальная грамматика** — это способ описания синтаксиса языков программирования.

**Терминальные символы** - символы алфавита, из которых строятся инструкции языка программирования. Для стадии лексческого анализа терминальные символы - литеры (characters) текста программы. Для стадии синтаксического анализа терминальные символы - токены.

**Нетерминальные символы** - символы, которые раскрываются согласно правилам грамматики.

**Правила грамматики** - правила, описывающие как в строке символов (терминальных и нетерминальных) раскрываются нетерминальные символы.

**Аксиома грамматики** - нетерминальный символ, выбранный в качестве стартового.

## 16. БНФ и синтаксические диаграммы.

**Форма Бекуса-Наура** - способ описания грамматики языка, где правила имеют вид:
<нетерминал> ::= <альтернатива> | ... | <альтернатива>

Нетерминалы записываются в угловых скобках, терминальные символы записываются или сами собой (для знаков операций, например), или словами БОЛЬШИМИ БУКВАМИ. Альтернативные варианты разделяются знаками `|`.

Пример:

    <Выражение> ::= <Слагаемое> | <Выражение> + <Слагаемое>
    <Слагаемое> ::= <Множитель> | <Слагаемое> * <Множитель>
    <Множитель> ::= ЧИСЛО | ( <Выражение> )

Впервые была использована при описании языка Алгол-60.

**Синтаксические диаграммы** - графический способ описания языка. Впервые были использованы Николасом Виртом при описании грамматики языка Паскаль в 1973.

## 17. LL(1)-грамматики: особенности и их использование.

LL(1)-грамматики - грамматики, в которых можно определить правило для раскрытие нетерминала по первому символу входной цепочки.

Пример: **не** LL(1)-грамматики:

    E → T | E + T
    T → F | T * F
    F → n | ( E )

Если имеем строку `n * n * n + n + n` и нетерминал `E`, то мы не знаем, по какому
правилу нужно раскрывать `E`. Поскольку в начале строки может быть сколько
угодно сомножителей, в общем случае, чтобы выбрать правило раскрытия для `E`
(т.е. `E → T` или `E → E + T`), нужно прочитать неизвестное количество входных
знаков. А для LL(k)-грамматики k должно быть конечно и фиксировано.

Пример: LL(1)-грамматика для тех же арифметических выражений:

    E → T E′
    E′ → ε | + T E′
    T → F T′
    T′ → ε | * F T′
    F → n | ( E )

Грамматика **не** LL(1) если разные правила начинаются с одинаковых символов:

    A → x a | x b

Грамматика **не** LL(1), если в правилах имеем т.н. левую рекурсию:

    A → x | A y

Преимущество LL(1)-грамматик — для них сравнительно легко написать синтаксический анализатор методом рекурсивного спуска.

## 18. Принцип построения лексического анализатора.

Анализатор проходит по тексту программы и в соответствии с алфавитом разбивает её на токены, т.е. определяет границы лексем и сохраняет информацию о них.

## 19. Принцип построения нисходящего синтаксического анализатора, осуществляющего разбор методом рекурсивного спуска.

**Метод рекурсивного спуска** — способ написания синтаксических анализаторов для LL(1)-грамматик на алгоритмических языках программирования. Для каждого нетерминала грамматики записывается процедура, тело которой выводится из правил для данного нетерминала.

Построенный синтаксический анализатор выдаёт сообщение о принадлежности входной строки к заданному языку.

Написание синтаксического анализатора состоит из этапов:

1. Составление LL(1)-грамматики для данного языка программирования.
2. Формальное выведение парсера из правил грамматики. Парсер либо молча принимает
   строку, либо выводит сообщение об ошибке.
3. Наполнение парсера семантическими действиями — построение дерева разбора,
   выполнение проверок на корректность типов операций, возможно даже, вычисление результата в процессе разбора.

## 20. Основные понятие ООП
\-

## 21. Модульное тестирование (юнит-тестирование), разработка через тестирование.

**Модульный тест** - тест, проверяющий работу малой части программы: функции, процедуры, класса, метода класса. Модульный тест самопроверяемый, выполнятеся быстро.

**Разработка через тестирование**
Выполняется короткими циклами длительностью ~1 минута.

1. Написание теста для неготовой функциональности
2. Написание функциональности, позволяющей пройти новому тесту. Теперь все тесты должны проходить.
3. Рефакторинг - улучшение внутренней структуры программы с точным сохранением внешнего поведения. Тесты должны по-прежнему проходить.

## 22. Способы разбора и вычисления значения арифметического выражения, записанного в инфиксной нотации, с учетом приоритетов операций и скобок. (В Scheme?)

Арифметическое выражение в инфиксной нотации разбирается непосредственно во время стадии синтаксического анализа.

#### Осуществляется лексический анализ: формируется последовательность из токенов:
1. имена переменных и знаки операций переходят в символические константы.
2. числа переходят в числовые константы.
3. скобки - в строки `"("` и `")"`.

#### Осуществляется синтаксический анализ согласно следующей грамматике:
```
<expression> ::= <term> <expression'> .
<expression'> ::= <add_operation> <term> <expression'> | e .
<term> ::= <factor> <term'> .
<term'> ::= <mult_operation> <factor> <term'> | e .
<factor> ::= <power> <factor'> .
<factor'> ::= <power_operation> <power> <factor'> | e .
<power> ::= <value> | "(" <expression> ")" | <unary_minus> <power> .
```

Терминалы - `<value>`, скобки и знаки операций

Разбор осуществляется методом рекурсивного спуска.

## 23. Основные постулаты языков программирования семейства Lisp.

1) Единство кода и данных.
2) Всё есть список.
3) Выражения являются списками, операция указывается в первом элементе.
4) Все выражения вычисляют значения.

## 24. Общая характеристика языка Scheme.

```
<term> ::= <atom> | <list>
<list> ::= (<terms>)
<terms> ::= e | <term> <terms>
<atom> ::= <variable> | <number> | <symbol> | <character> | <string> ...
```

**Scheme** - функциональный язык программирования, один из двух наиболее распространённых диалектов языка Lisp.

## 25. Типизация и система типов языка Scheme.

Система типов - строгая, динамическая. Типизация неявная.

## 26. Способы определения процедуры в языке Scheme. Формальные и фактические аргументы, применение к аргументам, возвращаемое значение.

Определение процедуры:
```
(define (<function name> <formal arguments>)
    <body>)
```
Вызов процедуры:
```
(<function name> <real arguments>)
; или
(apply <function name> <real arguments>)
```

## 27. Простые типы языка Scheme и основные операции над ними.

- Числа
  - Целые
  - Вещественные
  - Рациональные
  - Комплексные
    ```
    ; предикаты
    (number? 5) => #t
    (number? 1.234) => #t
    (complex? 1+i) => #t
    (rational? 1+i) => #f

    ; операции сравнения: <, >, <=, >=, =

    ; математические операции: +, -, *, /

    ; математические функции: expt, max, min, abs, sqrt
    ```
- Символы (цитаты)
  ```
  (symbol? 'abc) => #t
  (symbol? 5) => #f
  (symbol? #\c) => #f
  ; не чувствительны к регистру
  (equal? 'Abc 'abc) => #t
  ``` 
- Логический
  ```
  (boolean? #t) => #t
  (not #f) => #t
  (not #t) => #f
  (and #f #t) => #f
  ``` 
- Characters
  ```
  (char? #\c) => #t
  (char? 1) => #f
  
  (char=? #\a #\a) => #t
  (char<? #\a #\b) => #t
  (char>=? #\a #\b) => #f

  ; ci = case-insensetive
  (char-ci=? #\a #\A) => #t

  (char-downcase #\A) => #\a
  (char-upcase #\a) => #\A
  ```

## 28. Составные типы языка Scheme и основные операции над ними.

- Строки 
    ```
    ; последовательности, состоящие из characters

    (string? "abc") => #t

    (string #\a #\b #\c)
    (make-string <length> <char>)
    (define line "abacaba xyz")

    (string-ref line 0) => #\a

    (string-append line "qwerty") => "abacaba xyz qwerty"

    (string-set! line 0 #\b) => "bbacaba"

    (string-length "abc") => 3

    ; доступны операции сравнения по символу как и с character, так же с case-insensitive
    (substring line 8 11) => "xyz"  
    ```
- Векторы
  ```
  ; последовательности из каких-либо объектов
  (vector? #(1 "abc" 'abc "\T)) => #t
  (vector 0 1 2 3 4) => #(0 1 2 3 4)

  (define v (make-vector <length> <element>))

  ; процедуры vector-ref и vector-set! обращаются к элементам и изменяют их.
  ``` 

- Точечные пары и списки
  ```
  Точечная пара получается путём соединения двух любых произвольных значений в упорядоченную пару. Первый элемент называется car, второй - cdr, а процедура объединения - cons. Точечные пары нужно указывать самостоятельно с помощью цитирования.

  '(1 . #t) => (1 . #t)
  (pair? '(1 . #t)) => #t
  (define x (cons 1 #t))
  (car x) => 1
  (cdr x) => #t

  Для изменения значения можно использовать процедуры set-car! и set-cdr!
  (set-car! x 2)
  (set-cdr! x #f)
  x => (2 . #f)

  Точечные пары могут содержать в себе другие пары
  (define y (cons (cons 1 2) 3))
  y => ((1 . 2) . 3)

  c...r - сокращение для уровня вложенности "хвоста" пары. Напр: cadr, caddr, cadddr

  list - процедура для создания списка. Принимает любое количество аргументов и возвращает список, содержащий их.

  (list 1 2 3 4) => (1 2 3 4)
  '(1 2 3 4) => (1 2 3 4) ; цитирование подходит, когда не нужно вычислять реальные аргументы

  обращение по индексу, получение списка без первых k элементов:
  (define l (list 1 2 3 4))
  (list-ref l 0) => 1
  (list-tail l 1) => (2 3 4)

  предикаты
  (pair? '(1 . 2)) => #t
  (pair? '(1 2)) => #t
  (pair? '()) => #f
  (list? '()) => #t
  (null? '()) => #t
  (list? '(1 2)) => #t
  (list? '(1 . 2)) => #f

  ```
- Преобразование типов данных
  ```
  string->list
  list->string
  vector->list
  list->vector
  number->string
  string->number
  symbol->string
  string->symbol
  char->integer ; возвращает код по таблице ascii
  integer->char ; возвращает символ по таблице ascii
  ```

## 29. Символьный тип в языке Scheme и его применение.
- Characters
  ```
  (char? #\c) => #t
  (char? 1) => #f
  
  (char=? #\a #\a) => #t
  (char<? #\a #\b) => #t
  (char>=? #\a #\b) => #f

  ; ci = case-insensetive
  (char-ci=? #\a #\A) => #t

  (char-downcase #\A) => #\a
  (char-upcase #\a) => #\A

  (char->integer)
  (integer->char)
  ```
- Symbol
    ```
    (symbol? 'abc) => #t
    (symbol? 5) => #f
    (symbol? #\c) => #f
    ; не чувствительны к регистру
    (equal? 'Abc 'abc) => #t
    (symbol? 'foo) ; ===> #t
    (symbol? (car '(a b))) ; ===> #t
    (symbol? "bar") ; ===> #f
    (symbol? 'nil) ; ===> #t
    (symbol? '()) ; ===> #f
    (symbol? #f) ; ===> #f

    ; основные процедуры
    symbol->string
    string->symbol
    ```

## 30. Применение процедур (функций) высшего порядка для обработки списков на языке Scheme.

**Функции высших порядков** ­­- функции, которые могут принимать в качестве
аргументов и возвращать другие функции. Математики такую функцию чаще называют
оператором, например, оператор взятия производной или оператор интегрирования.

Функции высших порядков позволяют использовать карринг (каррирование) ­­- преобразование функции от
пары аргументов в функцию, берущую свои аргументы по одному. Это преобразование
получило свое название в честь Х. Карри.

```
(define a (list 1 2 3))
(define b (list -11 12 -13))

(map abs b) => (11 12 13) ; применяет процедуру к каждому элементу в списке, возвращает список изменённых элементов
(apply * a) => 6 ; применяет процедуру к элементам списка, как будто они являются её аргументами
```

## 31. Лексические замыкания (на примере) в языке Scheme. Свободные и связанные переменные. Использование лексических замыканий для локальных определений (запись конструкций let и let* с помощью анонимных процедур).

**Замыкание** - объект, включающий функцию и зафиксированные значения её свободных переменных.

**Замыкание** - особый вид функции. Она определена в теле другой функции и создаётся каждый раз во время её выполняния. Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная внутренняя функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.
Пример:
```
(define (make-adder n)
    (lambda (x) (+ x n))) ; возвращает замкнутое лямбда-выражение, в котором x - связанная переменная, а n - свободная, т. е. захваченная из внешнего контекста.

(define add-5 (make-adder 5))
(add-5 10) => 15
```
В случае замыкания ссылки на переменные внешней функции действительны внутри вложенной функции до тех пор, пока работает вложенная функция, даже если внешняя функция закончила работы, и переменные вышли из области видимости.

Замыкание связывает код функции с её лексическим окружением (местом, в котором она определена в коде). Лексические переменные замыкания отличаются от глобальных переменных тем, что они не занимают глобальное пространство имён. От переменных в объектах они отличаются тем, что привязаны к функциям, а не объектам.

**Свободная переменная** - переменная, которая используется в теле функции, но не является её параметром и/или определена в месте, находящемся за пределами функции (в `let`). Другими словами, если есть переменная, объявленная где-то в программе, и есть функция, которая имеет доступ к этой переменной, то такая переменная будет называться свободной.

**Связанные переменные** - переменные, которые либо являются параметрами данной функции, либо определены внутри этой функции.


**Запись конструкций let и let\* через анонимные процедуры:**

```
(define­syntax my­let
    (syntax­rules ()
        ((_ ((a b) ...) body ...)
            ((lambda (a ...) body ...) b ...))))
```

```
(define­syntax my­let*
    (syntax­rules ()
        ((_ ((a b)) body ...)
            (my­let ((a b)) body ...))
        ((_ ((a b) (c d) ...) body ...)
            (my­let ((a b))
            (my­let* ((c d) ...)
                body ...)))))
```

## 32. Лексические замыкания (на примере) в языке Scheme. Свободные и связанные переменные. Использование лексического замыкания для определения процедуры со статической переменной.

см. вопрос 31

Статическая переменная - переменная, сохраняющая своё значение между вызовами процедуры, в которой она объявлена. 
Пример:

(define counter
    (let ((n 0))
        (lambda ()
            (set! n (+ n 1))
            n)))

(list (counter) (counter) (counter)) => (1 2 3)

## 33. Особенности логических операций в Scheme.

В Scheme только значение `#f` является ложным. Все остальные объекты (включая пустые списки) считаются истинными `#t`.

Процедура `(and ...)` (логическое `и`) вычисляет аргументы слева направо до первого выражения, значение которого ложно. Следующие за ним не вычисляются. Если все выражения истинны, то возвращается результат последнего выражения. Если аргументов нет, возвращается возвращается `#t`.

Примеры:
```
(and (= 2 2) (> 2 1)) => #t
(and (= 2 2) (< 2 1)) => #f
(and 1 2 'c '(f g)) => (f g) 
```

Процедура `(or ...)` (логическое `или`) вычисляет аргументы слева направо до первого выражения, значение которого истинно. Следующие за ним не вычисляются. Если все выражения ложны, то возвращается результат последнего выражения. Если выражений нет, возвращается `#f`.

Примеры:
```
(or (= 2 2) (< 2 1)) => #t
(or #f #f #f) => #f
(or (memq 'b '(a b c)) (/ 3 0)) => (b c)
```

## 34. Гигиенические макросы в языке Scheme.

**Макросы Scheme** - инструмент, который позволяет расширять синтаксис языка, создавая
новые конструкции. Определение макроса начинается с команды `define­-syntax`.
```
(define­syntax macro
    (syntax­rules (<keywords>)
        ((<pattern>) <template>)
        ...
        ((<pattern) <template>)))
```

`<keywords>` — Ключевые слова, которые можно будет использовать в описании шаблона.
Например, можно написать макрос для конструкции "(foreach (item in items) ...)", в данном
случае ключевым словом будет "in", которое обязательно должно присутствовать.

`<pattern>` — Шаблон, описывающий, что на входе у макроса.

`<template>` — Шаблон, описывающий, во что должен быть трансформирован. В макросе
многоточие "…" означает, что тело может содержать одну или более форм.

Примеры макросов:
```
(define­syntax when
    (syntax­rules ()
        ((_ condition expr ...)
            (if condition
                (begin expr ...)))))

(define­syntax unless
    (syntax­rules ()
        ((_ condition expr ...)
            (when (not condition) expr ...))))
```

## 35. Продолжения в языке Scheme.

**Продолжение (continuation)** - это "замороженное состояние вычислительного процесса, контекст вычисления".
```
(def (fact n)
    (if (= n 0)
        1
        (* n (fact (- n 1)))))
        
(fact 6)
(if (= 6 0) 1 (* 6 (fact (- 6 1))))
(if #f 1 (* 6 (fact (- 6 1))))
(* 6 (fact (- 6 1)))
(* 6 (fact 5))
(* 6 (if (= 5 0) 1 (* 5 (fact (- 5 1)))))
(* 6 (if #f ... ...))
...
```
Выражения "с дыркой" - это контекст вычислений. Мы взяли какое-то подвыражения и его заменили на "дырку".
(* 6 (* 5 (* 4 <>)))
               ||
              дырка

`call-with-current-continuation` позволяет получить контекст вычислений
```
(define call/cc call-with-current-continuation)

(call/cc (lambda (c) expr)) ; c - контекст
```
```
> (define x #f) ; переменная для хранения continuation

> (+ 2 (call/cc 
          (lambda (cc)
           (set! x cc)  ; х присваивается текущее continuation cc; выглядещее как, (+ 2 _)
           3)))         ; возвращает 5
5

> (x 4)                 ; возвращает 6
6

(* 123 (+ 345 (* 789 (x 5)))) ; вернёт 7, посколько текущее continuation заменяется на х, которое (+2 _), поэтому происходит (+ 2 5) и возвращается 7
```
```
(point 7)
----------
(display (* 100 7)) --> 700


(display (* 100
            (begin
                (set! point <контекст>)
                3)))

(display (* 100 3))
(display 300)
                
    <контекст>:
    (display (* 100 <>))


(define (product xs)
    (cond ((null? xs) 1
        (else (* (car xs) (product (cdr xs)))))))
        
(define (product xs)
    (call/cc (lambda (return)
                (define (rec xs)
                    (cond
                        ((null? xs) 1)
                        ((= 0 (car xs)) (return 0))
                        (else (* (car xs) (rec (cdr xs)))))))))
                        
(define point #f)
(call/cc (lambda (c)
            (set! point c)))
            
(define (error msg) ; вызов error останавливает
    (display msg)
    (newline)
    (point #f))

(display (any-func-call-error))
(display 'FINISH)
```

## 36. Ввод-вывод в языке Scheme.

Для ввода-вывода используется тип `port`. Два стандартных порта для ввода-вывода Scheme - `current-input-port` (клавиатура) и `current-output-port` (экран), соответствующие стандартным потокам ввода-вывода в Unix.

- (write object port) - выведет закавыченный результат, в машиночитаемом виде
- (display obejct port) - выведет незакавыченный результат, т.е. в человекочиатемом виде
- (newline port) - записывает символ конца строки
- (write-char char port) - записывает `character` в порт

В указанных выше процедурах можно не указывать порт, т.к. стандартно используется current-output-port

- (read port) - считывание потока ввода до первого пробельного символа (пробел, табуляция, newline)
- (read-char port) - считывание одного символа, осуществляется переход на следующий символ.
- (peek-char port) - считывание следующего символа из порта, переход на следующий символ не осуществляется

**Можно записывать и считывать:**
- #t #f
- число
- строку
- symbol
- character
- списки и векторы

**Работа с файлами:**
```
(oef-object? object) => #t/#f проверка на конец файла
(input-port? object)
(output-port? object) ; предикаты на проверку типа порта

(define port (open-input-port "in.txt")) - определили порт как открытый файл in.txt

(close-input-port port) - закрыли файл in.txt
;также можно open-input-file и close-input-file

(call-with-input-file "file.txt" <procedure>) ; файл доллжен существовать, procedure - процедура, применяемая к файлу, имеет аргумент порт. Порт автоматически закрывается.

(with-input/output-from/to-file <filename> <procedure>) ; файл должен существовать. procedure - процедура, применяемая к файлу, не имеет аргументов. Используются стандартные порты

```
## 37. Средства для метапрограммирования в Scheme.

Программа переходит в данные с помощью quote.
Данные переходят в программу с помощью eval.

Процедура `eval`: (eval <expression\> <environment\>) 

Пример:
```
(define f (list '+ 1 2))
(eval f (interaction-environment)) => 3
```

**Виды окружений:**

1. (scheme-report-environment 5) - все встроенные функции и макросы Scheme
2. (null-environment 5) - только встроенные макросы Scheme
3. (interaction-environment) - все глобальные определения

## 38. Хвостовая рекурсия и ее оптимизация интерпретатором языка Scheme.

**Рекурсивная функция** - функция, определённая через саму себя.

**Хвостовая рекурсия** - частный случай рекурсии, когда любой рекурсивный вызов является последней операцией перед возвратом из функции.

Пример:
```
(define (factorial n)
    (define (fac-times n acc)
        (if (= n 0)
            acc
            (fac-times (- n 1) (* acc n))))
    (fac-times n 1))
```

В Scheme заложена оптимизация хвостового вызова. Фрейм стека вызывающей процедуры заменяется на фрейм стека вызываемой. Если хвостовой вызов является рекурсивным, фреймы стека не накапливаются.

Хвостовая рекурсия в Scheme эквивалентна итерации по вычислительным затратам.

## 39. Основные управляющие конструкции языка Scheme.

define, define-syntax, lambda, if, cond, set!, begin

## 40. Ассоциативные списки

Ассоциативный список - структура данных, представляющая собой словарь, т.е. позволяющая хранить пары вида (<ключ> <значение>), поддерживает операции добавления, удаления пары и поиска по ключу.

```
(define e '((a 1) (b 2) (c 3)))
(alist ? e) => #t
(assq 'a e) => (a 1)
(assq 'd e) => #f

(assq object alist) ; сравнение по eq?
(assv object alist) ; сравнение по eqv?
(assoc object alist) ; сравнение по equal?
```

