# Конспект по ЯП Python

Python - высокоуровневый интерпретируемый мультипарадигменный язык программирования общего назначения.

## Типизация и система типов в Python

В Python имеются встроенные типы: 
1. None (неопределенное значение переменной)
2. Логические переменные (Boolean Type)
3. Числа (Numeric Type)
    - int – целое число
    - float – число с плавающей точкой
    - complex – комплексное число
4. Списки (Sequence Type)
    - list – список
    - tuple – кортеж
    - range – диапазон
5. Строки (Text Sequence Type )
    - str
6. Бинарные списки (Binary Sequence Types)
    - bytes – байты
    - bytearray – массивы байт
    - memoryview – специальные объекты для доступа к внутренним данным объекта через protocol buffer
7. Множества (Set Types)
    - set – множество
    - frozenset – неизменяемое множество
8. Словари (Mapping Types)
    - dict – словарь

В Python существуют изменяемые и неизменяемые типы. 

К ***неизменяемым*** (immutable) типам относятся: целые числа (int),  числа с плавающей точкой (float), комплексные числа (complex), логические переменные (bool), кортежи (tuple), строки (str) и неизменяемые множества (frozen set).

К ***изменяемым*** (mutable) типам относятся: списки (list), множества (set), словари (dict).

Язык программирования имеет динамическую сильную систему типов и неявную типизацию. Пример: 
```
a = 10
b = True
c = "line"
d = [1, 2, 3]

# при объявлении переменных явно не указывается тип

print(type(a), type(b), type(c), type(d)) # выведет <class 'int'> <class 'bool'> <class 'str'> <class 'list'>

print(c - d) # вычтем из строки список - получим ошибку TypeError: unsupported operand type(s) for -: 'str' and 'list'
```

## Основные управляющие конструкции

### Условные операторы
Для простых ветвлений можно использовать операторы _if_ и _else_. Тела операторов отделяются отступами, при этом _else_ является необязательным. Пример:
```
a = 5
b = 10

if a < b:
    print("YES\n")
else :
    print("NO\n")
```
Имеется возможность формировать логические выражения с помощью ключевых слов _and_, _or_, _not_. Пример:
```
a = [1, 2, 3]
b = [4, 5, 6]
c = False

if (len(a) == 3 and (7 in b) or not c):
    print("YES\n")
else:
    print("NO\n")
```

В языке Python отсутствует специальный оператор проверки значений, такой как switch-case или cond. Чтобы выполнить проверку на соответствие нескольким значениям, можно использовать оператор _elif_, например:
```
x = int(input())

if (x < 0):
    print(-1)
elif (x == 0): # elif может повторяться сколько угодно раз
    print(0)
else:
    print(1)
```

### Итерации и циклы

Для организации циклов наиболее часто используется оператор цикла _for_, который позволяет выполнить обход элементов коллекции. Итерации – одна
из самых богатых особенностей языка Python.  Однако наиболее  часто используемой формой итераций является простой цикл по элементам последовательности, такой как строка, список или кортеж. Пример:
```
powers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for n in powers:
    print ("2 в степени %d = %d" % (n, 2 ** n))
```

Этот же результат можно получить с помощью цикла по заранее заданному диапазону целых чисел:
```
for n in range(1, 11):
    print ("2 в степени %d = %d" % (n, 2**n))
```
Функция _range(i,j [,stride])_ создает объект, представляющий диапазон целых чисел со значениями от i по j - 1. Если начальное значение не указано,
оно берется равным нулю. В третьем необязательном аргументе stride можно передать шаг изменения значений. Например:
```
a = range(5) # a = 0,1,2,3,4
b = range(1, 8) # b = 1,2,3,4,5,6,7
c = range(0, 14, 3) # c = 0,3,6,9,12
d = range(8, 1, -1) # d = 8,7,6,5,4,3,2
```

Возможности оператора _for_ не ограничиваются последовательностями целых чисел, он также может использоваться для реализации итераций через объекты самых разных типов, включая строки, списки, словари и файлы. Например:
```
line = "thisissimplelinemadeforexample"

for c in line:
    print(c, end=' ')
```
```
d = {'key1': 'val1', 'key2': 'val2', 'key3': 'val3'}

for key in d:
    print(key, d[key])
```
Оператор цикла _while_ вычисляет условное выражение, следующего прямо за ним. Если результат выражения оценивается как истина, выполняется тело _while_. Условное выражение, а вместе с ним и тело цикла, вычисляется снова и снова, пока не будет получено ложное значение. Пример: 
```
i = 0

while (i < 10):
    print(i, end = ' ')
    i += 1
    
# 0 1 2 3 4 5 6 7 8 9
```

Для выхода из _for_ или _while_ используется оператор _break_. Оператор _continue_ осуществляет немедленный переход в верхнюю часть объемлющего оператора _for_ или _while_. Оператор _pass_ - оператор-заполнитель, не выполняющий никаких действий. Применяется, например, для фиктивного обозначения тела функции.

### Функции
Оператор _def_ образует новые функции. Он создаёт объект функции и присваивает его переменной имя. При каждом обращении к объекту функции формируется новая локальная область действия, где присвоенные имена оказываются по умолчанию локальными для вызова функции (если они не объявлены как _global_ или _nonlocal_). Аргументы передаются путём присваивания. В заголовке оператора _def_ они могут быть определены следующим образом:
1. name
2. name=value (значение по умолчанию, если name не передано)
3. \*name (накапливает дополнительные позиционные аргументы в виде нового кортежа _name_)
4. \*\*name (накапливает дополнительные именованные аргументы в виде нового словаря _name_)
5. \*smth, name[=value] (аргументы, указываемые после знака \*)
6. \*,name[=value] (то же, что и п.5, если иначе не указан знак *)

Пример:
```
def gcd(a, b):
    if (b == 0):
        return a
    else:
        return gcd(b, a % b)

result = gcd(35, 165) # result = 5
```

```
# аргументы как кортеж

def f(*args):
    print("amount of args: ", len(args))
    print(args)

print(f(1, 2, 3, "hello"))

# amount of args:  4
# (1, 2, 3, 'hello')
# f вернёт None, т.к. None возвращают все функции, у которых отсутствует оператор return
```

```
# аргументы как словарь:

def f(**kwargs):
    print(kwargs)

print(f(first=1, second=2, third=3))

# {'first': 1, 'second': 2, 'third': 3}
```

```
# функция с переменным числом аргументов. оба варианта одновременно:

def f(*args, **kwargs):
    print(args)
    print(kwargs)

print(f(1, 2, 3, fourth=4, fifth=5))
# (1, 2, 3)
# {’fifth’: 5, ’fourth’: 4}
```

## Подмножество языка для функционального программирования

### Иммутабельность данных

### Функции как объекты 1-го класса
Все объекты в языке Python могут быть отнесены к объектам первого класса. Это означает, что все объекты, имеющие идентификатор, имеют одинаковый статус. Это также означает, что все объекты, имеющие идентификатор, можно интерпретировать как данные. Функции, в том числе, являются объектами первого класса. Это означает, что язык поддерживает передачу функций в качестве аргументов другим функциям, возврат их как результат других функций, присваивание их переменным или сохранение в структурах данных.
#### Анонимные функции
Функции могут быть также созданы в форме лямбда-выражения: _lambda arg1, arg2, ... : expr_. В этой форме создаётся новый объект функции, который возвращается для вызова в дальнейшем вместо присваивания по имени. Каждый аргумент argi оказывается таким же, как и в операторе _def_, а _expr_ - возвращаемым значением при вызовах. Выполнение кода в _expr_ откладывается до момента вызова. Пример:
```
myabs = lambda x: -x if x < 0 else x

print(myabs(-100)) # 100
print(myabs(100)) # 100
```
#### Функции высшего порядка
Как было сказано выше, функции можно передавать в качестве аргументов или возвращать в качестве результата. Пример:
```
def f(x):
    return x + 3

def g(func, x):
    return func(x) * func(x)

print(g(f, 7)) # 100
```

```
print(list(map(abs, [-1, -2, -3, -4]))) # [1, 2, 3, 4]

print(list(filter(lambda x: x % 2 != 0, [1, 2, 3, 4]))) # [1, 3]

print([x ** 3 for x in range(10)]) # [0, 1, 8, 27, 64, 125, 216, 343, 512, 729]
```

#### Встроенные функции высших порядков для работы с последовательностями
1. ***apply(f, \*args[, \*\*kwargs])*** применяет функцию, переданную в качестве первого аргумента, к параметрам, которые переданы вторым и третьим аргументом. 
2. ***range(i,j [,stride])*** (см. пункт циклы и итерации)
3. ***map(f, *args)*** используется для применения некоторой функции ко всем элементам последовательности. Первый параметр - функция, которая будет применяться ко всем элементам. каждый следующий n + 1 - й параметр должен быть последовательностью, т. к. каждый его элемент будет исполльзован в качестве n-го параметра при вызове функции f(). Результатом будет список, составленный из результатов выполнения этой функции.
4. ***filter(f, iterable, ...)*** принимает функцию с условием и последовательность, из которой берутся значения. В результирующую последовательность попадут только те значения из исходной, для которой f() возвратит истину
5. ***sum(iterable,/,start=0)*** получает сумму элементов. Пример: ```sum(rage(10)) # 45```
6. ***reduce(f, iterable,/,start=0)*** применяется для организации цепочечных вычислений (вычислений с накоплением результата, свёртка). Вот как выглядит реализация функции ***sum*** с помощью ***reduce***: 
```
def sum(lst, start):
    return reduce(lambda x, y: x + y, lst, start)
```
7. ***sorted(iterable, \*, key=None, reverse=False)*** возвращает отсортированный лист iterable.

#### Остальные функции: https://docs.python.org/3/library/functions.html

## Функции для работы с потоками ввода/вывода

### Консольный ввод/вывод
Для считывания вводимых с клавиатуры данных используется функция _input()_. Если нужно считать целое число, то строку, получаемую с помощью _input_ можно перевести в int. Для вывода данных используется функция _print()_. По умолчанию, для разделения элементов в функции _print_ используется пробел. Для замены разделителя нужно использовать параметр _sep_. В качестве конечного элемента выводимой строки используется символ перевода строки. Для его замены используется параметр _end_.
```
>>> val = int(input())
123
>>> print(val)
123
>>> type(val)
<class 'int'>
>>> a = input()
hello
>>> print(a)
hello
>>> print("A", "B", "C")
A B C
print("A", "B", "C", sep="#")
A#B#C
>>> for i in range(3):
    print("[i: " + str(i) + "]", end=" -- ")
[i: 0] -- [i: 1] -- [i: 2] -- 
```
Преобразование строки в список осуществляется с помощью метода _split()_, по умолчанию, в качестве разделителя, используется пробел.
```
>>> l = input().split()
1 2 3 4 5 6 7
>>> print(l)
['1', '2', '3', '4', '5', '6', '7']
```
Разделитель можно заменить, указав его в качестве аргумента метода split().
```
>>> nl = input().split("-")
1-2-3-4-5-6-7
>>> print(nl)
['1', '2', '3', '4', '5', '6', '7']
```
Для считывания списка чисел с одновременным приведением их к типу int можно воспользоваться вот такой конструкцией.
```
>>> nums = map(int, input().split())
1 2 3 4 5 6 7
>>> print(list(nums))
[1, 2, 3, 4, 5, 6, 7]
```

### Работа с файлами
#### Открытие и закрытие файла
Для открытия файла используется функция _open()_, которая возвращает файловый объект. Наиболее часто используемый вид данной функции выглядит так _open(file_name, access_mode)_. Для закрытия файла используется метод _close()_.

Для указания режима доступа используется следующие символы:
‘r’ – открыть файл для чтения;
‘w’ – открыть файл для записи;
‘x’ – открыть файл с целью создания, если файл существует, то вызов функции open завершится с ошибкой;
‘a’ – открыть файл для записи, при этом новые данные будут добавлены в конец файла, без удаления существующих;
‘b’ – бинарный режим;
‘t’ – текстовый режим;
‘+’ – открывает файл для обновления.

По умолчанию файл открывается на чтение в текстовом режиме. У файлового объекта есть следующие атрибуты.
***file.closed*** – возвращает true если файл закрыт и false в противном случае;
***file.mode*** – возвращает режим доступа к файлу, при этом файл должен быть открыт;
***file.name*** – имя файла.

```
>>> f = open("test.txt", "r")
>>> print("file.closed: " + str(f.closed))
file.closed: False
>>> print("file.mode: " + f.mode)
file.mode: r
>>> print("file.name: " + f.name)
file.name: test.txt
```

#### Чтение данных из файла

Чтение данных из файла осуществляется с помощью методов _read(size)_ и _readline()_. Метод _read(size)_ считывает из файла определенное количество символов, переданное в качестве аргумента. Если использовать этот метод без аргументов, то будет считан весь файл.
```
>>> f = open("test.txt", "r")
>>> f.read()
'1 2 3 4 5\nWork with file\n'
>>> f.close()
```
```
>>> f = open("test.txt", "r")
>>> f.read(5)
'1 2 3'
>>> f.close()
```
```
>>> f = open("test.txt", "r")
>>> f.readline()
'1 2 3 4 5\n'
>>> f.close()
```
Построчное считывание можно организовать с  помощью оператора _for_.
```
>>> f = open("test.txt", "r")
>>> for line in f:
...     print(line)
...
1 2 3 4 5
Work with file

>>> f.close()
```
#### Запись данных в файл
Для записи данных файл используется метод _write(line)_, при успешной записи он вернет количество записанных символов.
```
>> f = open("test.txt", "a")
>>> f.write("Test string")
11
>>> f.close()
```
#### Дополнительные методы
Метод _tell()_ возвращает текущую позицию “условного курсора” в файле. Например, если вы считали пять символов, то “курсор” будет установлен в позицию 5.
```
>>> f = open("test.txt", "r")
>>> f.read(5)
'1 2 3'
>>> f.tell()
5
>>> f.close()
```
Метод _seek(position)_ выставляет позицию в файле.
```
>>> f = open("test.txt", "r")
>>> f.tell()
0
>>> f.seek(8)
8
>>> f.read(1)
'5'
>>> f.tell()
9
>>> f.close()
```
Хорошей практикой при работе с файлами является применение оператора _with_. При его использовании нет необходимости закрывать файл, при завершении работы с ним, эта операция будет выполнена автоматически.
```
>>> with open("test.txt", "r") as f:
...     for line in f:
...             print(line)
...
1 2 3 4 5
Work with file
Test string
>>> f.closed
True
```

### Символьные строки
Обычный строковый объект типа ***str*** представляет собой неизменяемую последовательность символов, доступных по смещению, обозначающему их расположение в строке. Символы в строковом объекте являются порядковыми номерами кодовых точек в базовом наборе символов, а отдельные символы - строковыми объектами единичной длины.

Некоторые операции со строками:
```
int("123") # 123
float("1.23") # 1.23
"    \n\tabc  ".strip() # abc
"a b c".split() # ['a', 'b', 'c']
"a-b-c".split() # ['a', 'b', 'c']
a = "aba"
b = "caba"
a + b # "abacaba"
"The sum of 1 + 2 is {0}".format(1 + 2)
```
#### Остальные методы: https://docs.python.org/3/library/stdtypes.html#string-methods

