# Конспект по ЯП Python

Python - высокоуровневый интерпретируемый мультипарадигменный язык программирования общего назначения.

## Типизация и система типов в Python

В Python имеются встроенные типы: 
1. None (неопределенное значение переменной)
2. Логические переменные (Boolean Type)
3. Числа (Numeric Type)
    - int – целое число
    - float – число с плавающей точкой
    - complex – комплексное число
4. Списки (Sequence Type)
    - list – список
    - tuple – кортеж
    - range – диапазон
5. Строки (Text Sequence Type )
    - str
6. Бинарные списки (Binary Sequence Types)
    - bytes – байты
    - bytearray – массивы байт
    - memoryview – специальные объекты для доступа к внутренним данным объекта через protocol buffer
7. Множества (Set Types)
    - set – множество
    - frozenset – неизменяемое множество
8. Словари (Mapping Types)
    - dict – словарь

В Python существуют изменяемые и неизменяемые типы. 

К ***неизменяемым*** (immutable) типам относятся: целые числа (int),  числа с плавающей точкой (float), комплексные числа (complex), логические переменные (bool), кортежи (tuple), строки (str) и неизменяемые множества (frozen set).

К ***изменяемым*** (mutable) типам относятся: списки (list), множества (set), словари (dict).

Язык программирования имеет динамическую сильную систему типов и неявную типизацию. Пример: 
```
a = 10
b = True
c = "line"
d = [1, 2, 3]

# при объявлении переменных явно не указывается тип

print(type(a), type(b), type(c), type(d)) # выведет <class 'int'> <class 'bool'> <class 'str'> <class 'list'>

print(c - d) # вычтем из строки список - получим ошибку TypeError: unsupported operand type(s) for -: 'str' and 'list'
```

## Основные управляющие конструкции

### Условные операторы
Для простых ветвлений можно использовать инструкции _if_ и _else_. Тела инструкций отделяются отступами, при этом инструкция _else_ является необязательной. Пример:
```
a = 5
b = 10

if a < b:
    print("YES\n")
else :
    print("NO\n")
```
Имеется возможность формировать логические выражения с помощью ключевых слов _and_, _or_, _not_. Пример:
```
a = [1, 2, 3]
b = [4, 5, 6]
c = False

if (len(a) == 3 and (7 in b) or not c):
    print("YES\n")
else:
    print("NO\n")
```

В языке Python отсутствует специальная инструкция проверки значений, такая как switch-case или cond. Чтобы выполнить проверку на соответствие нескольким значениям, можно использовать инструкцию _elif_, например:
```
x = int(input())

if (x < 0):
    print(-1)
elif (x == 0): # elif может повторяться сколько угодно раз
    print(0)
else:
    print(1)
```

### Итерации и циклы

Для организации циклов наиболее часто используется оператор цикла _for_, который позволяет выполнить обход элементов коллекции. Итерации – одна
из самых богатых особенностей языка Python.  Однако наиболее  часто используемой формой итераций является простой цикл по элементам последовательности, такой как строка, список или кортеж. Пример:
```
powers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for n in powers:
    print ("2 в степени %d = %d" % (n, 2 ** n))
```

Этот же результат можно получить с помощью цикла по заранее заданному диапазону целых чисел:
```
for n in range(1, 11):
    print ("2 в степени %d = %d" % (n, 2**n))
```
Функция _range(i,j [,stride])_ создает объект, представляющий диапазон целых чисел со значениями от i по j - 1. Если начальное значение не указано,
оно берется равным нулю. В третьем необязательном аргументе stride можно передать шаг изменения значений. Например:
```
a = range(5) # a = 0,1,2,3,4
b = range(1, 8) # b = 1,2,3,4,5,6,7
c = range(0, 14, 3) # c = 0,3,6,9,12
d = range(8, 1, -1) # d = 8,7,6,5,4,3,2
```

Возможности оператора _for_ не ограничиваются последовательностями целых чисел, он также может использоваться для реализации итераций через объекты самых разных типов, включая строки, списки, словари и файлы. Например:
```
line = "thisissimplelinemadeforexample"

for c in line:
    print(c, end=' ')
```
```
d = {'key1': 'val1', 'key2': 'val2', 'key3': 'val3'}

for key in d:
    print(key, d[key])
```
Оператор цикла _while_ вычисляет условное выражение, следующего прямо за ним. Если результат выражения оценивается как истина, выполняется тело _while_. Условное выражение, а вместе с ним и тело цикла, вычисляется снова и снова, пока не будет получено ложное значение. Пример: 
```
i = 0

while (i < 10):
    print(i, end = ' ')
    i += 1
    
# 0 1 2 3 4 5 6 7 8 9
```

Для выхода из _for_ или _while_ используется оператор _break_. Оператор _continue_ осуществляет немедленный переход в верхнюю часть объемлющего оператора _for_ или _while_. Оператор _pass_ - оператор-заполнитель, не выполняющий никаких действий. Применяется, например, для фиктивного обозначения тела функции.

### Функции
Оператор _def_ образует новые функции. Он создаёт объект функции и присваивает его переменной имя. При каждом обращении к объекту функции формируется новая локальная область действия, где присвоенные имена оказываются по умолчанию локальными для вызова функции (если они не объявлены как _global_ или _nonlocal_). Аргументы передаются путём присваивания. В заголовке оператора _def_ они могут быть определены следующим образом:
1. name
2. name=value (значение по умолчанию, если name не передано)
3. \*name (накапливает дополнительные позиционные аргументы в виде нового кортежа _name_)
4. \*\*name (накапливает дополнительные именованные аргументы в виде нового словаря _name_)
5. \*smth, name[=value] (аргументы, указываемые после знака \*)
6. \*,name[=value] (то же, что и п.5, если иначе не указан знак *)

Пример:
```
def gcd(a, b):
    if (b == 0):
        return a
    else:
        return gcd(b, a % b)

result = gcd(35, 165) # result = 5
```

```
# аргументы как кортеж

def f(*args):
    print("amount of args: ", len(args))
    print(args)

print(f(1, 2, 3, "hello"))

# amount of args:  4
# (1, 2, 3, 'hello')
# f вернёт None, т.к. None возвращают все функции, у которых отсутствует оператор return
```

```
# аргументы как словарь:

def f(**args):
    print(args)

print(f(first=1, second=2, third=3))

# {'first': 1, 'second': 2, 'third': 3}
```

```
# функция с переменным числом аргументов. оба варианта одновременно:

def f(*args1, **args2):
    print(args1)
    print(args2)

print(f(1, 2, 3, fourth=4, fifth=5))
# (1, 2, 3)
# {’fifth’: 5, ’fourth’: 4}
```
