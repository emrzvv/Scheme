# Конспект по ЯП Python

Python - высокоуровневый интерпретируемый мультипарадигменный язык программирования общего назначения.

## Типизация и система типов в Python

В Python имеются встроенные типы: 
1. None (неопределенное значение переменной)
2. Логические переменные (Boolean Type)
3. Числа (Numeric Type)
    - int – целое число
    - float – число с плавающей точкой
    - complex – комплексное число
4. Списки (Sequence Type)
    - list – список
    - tuple – кортеж
    - range – диапазон
5. Строки (Text Sequence Type )
    - str
6. Бинарные списки (Binary Sequence Types)
    - bytes – байты
    - bytearray – массивы байт
    - memoryview – специальные объекты для доступа к внутренним данным объекта через protocol buffer
7. Множества (Set Types)
    - set – множество
    - frozenset – неизменяемое множество
8. Словари (Mapping Types)
    - dict – словарь

В Python существуют изменяемые и неизменяемые типы. 

К ***неизменяемым*** (immutable) типам относятся: целые числа (int),  числа с плавающей точкой (float), комплексные числа (complex), логические переменные (bool), кортежи (tuple), строки (str) и неизменяемые множества (frozen set).

К ***изменяемым*** (mutable) типам относятся: списки (list), множества (set), словари (dict).

Язык программирования имеет динамическую сильную систему типов и неявную типизацию. Пример: 
```
a = 10
b = True
c = "line"
d = [1, 2, 3]

# при объявлении переменных явно не указывается тип

print(type(a), type(b), type(c), type(d)) # выведет <class 'int'> <class 'bool'> <class 'str'> <class 'list'>

print(c - d) # вычтем из строки список - получим ошибку TypeError: unsupported operand type(s) for -: 'str' and 'list'
```

## Основные управляющие конструкции

### Условные операторы
Для простых ветвлений можно использовать инструкции _if_ и _else_. Тела инструкций отделяются отступами, при этом инструкция _else_ является необязательной. Пример:
```
a = 5
b = 10

if a < b:
    print("YES\n")
else :
    print("NO\n")
```
Имеется возможность формировать логические выражения с помощью ключевых слов _and_, _or_, _not_. Пример:
```
a = [1, 2, 3]
b = [4, 5, 6]
c = False

if (len(a) == 3 and (7 in b) or not c):
    print("YES\n")
else:
    print("NO\n")
```

В языке Python отсутствует специальная инструкция проверки значений, такая как switch-case или cond. Чтобы выполнить проверку на соответствие нескольким значениям, можно использовать инструкцию _elif_, например:
```
x = int(input())

if (x < 0):
    print(-1)
elif (x == 0): # elif может повторяться сколько угодно раз
    print(0)
else:
    print(1)
```

### Итерации и циклы

Для организации циклов наиболее часто используется оператор цикла _for_, который позволяет выполнить обход элементов коллекции. Итерации – одна
из самых богатых особенностей языка Python.  Однако наиболее  часто используемой формой итераций является простой цикл по элементам последовательности, такой как строка, список или кортеж. Пример:
```
powers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for n in powers:
    print ("2 в степени %d = %d" % (n, 2 ** n))
```

Этот же результат можно получить с помощью цикла по заранее заданному диапазону целых чисел:
```
for n in range(1, 11):
    print ("2 в степени %d = %d" % (n, 2**n))
```
Функция _range(i,j [,stride])_ создает объект, представляющий диапазон целых чисел со значениями от i по j - 1. Если начальное значение не указано,
оно берется равным нулю. В третьем необязательном аргументе stride можно передать шаг изменения значений. Например:
```
a = range(5) # a = 0,1,2,3,4
b = range(1, 8) # b = 1,2,3,4,5,6,7
c = range(0, 14, 3) # c = 0,3,6,9,12
d = range(8, 1, -1) # d = 8,7,6,5,4,3,2
```

Возможности оператора _for_ не ограничиваются последовательностями целых чисел, он также может использоваться для реализации итераций через объекты самых разных типов, включая строки, списки, словари и файлы. Например:
```
line = "thisissimplelinemadeforexample"

for c in line:
    print(c, end=' ')
```
```
d = {'key1': 'val1', 'key2': 'val2', 'key3': 'val3'}

for key in d:
    print(key, d[key])
```
Оператор цикла _while_ вычисляет условное выражение, следующего прямо за ним. Если результат выражения оценивается как истина, выполняется тело _while_. Условное выражение, а вместе с ним и тело цикла, вычисляется снова и снова, пока не будет получено ложное значение. Пример: 
```
i = 0

while (i < 10):
    print(i, end = ' ')
    i += 1
    
# 0 1 2 3 4 5 6 7 8 9
```

Для выхода из _for_ или _while_ используется оператор _break_. Оператор _continue_ осуществляет немедленный переход в верхнюю часть объемлющего оператора _for_ или _while_. Оператор _pass_ - оператор-заполнитель, не выполняющий никаких действий. Применяется, например, для фиктивного обозначения тела функции.

### Функции
Оператор _def_ образует новые функции. Он создаёт объект функции и присваивает его переменной имя. При каждом обращении к объекту функции формируется новая локальная область действия, где присвоенные имена оказываются по умолчанию локальными для вызова функции (если они не объявлены как _global_ или _nonlocal_). Аргументы передаются путём присваивания. В заголовке оператора _def_ они могут быть определены следующим образом:
1. name
2. name=value (значение по умолчанию, если name не передано)
3. \*name (накапливает дополнительные позиционные аргументы в виде нового кортежа _name_)
4. \*\*name (накапливает дополнительные именованные аргументы в виде нового словаря _name_)
5. \*smth, name[=value] (аргументы, указываемые после знака \*)
6. \*,name[=value] (то же, что и п.5, если иначе не указан знак *)

Пример:
```
def gcd(a, b):
    if (b == 0):
        return a
    else:
        return gcd(b, a % b)

result = gcd(35, 165) # result = 5
```

```
# аргументы как кортеж

def f(*args):
    print("amount of args: ", len(args))
    print(args)

print(f(1, 2, 3, "hello"))

# amount of args:  4
# (1, 2, 3, 'hello')
# f вернёт None, т.к. None возвращают все функции, у которых отсутствует оператор return
```

```
# аргументы как словарь:

def f(**kwargs):
    print(kwargs)

print(f(first=1, second=2, third=3))

# {'first': 1, 'second': 2, 'third': 3}
```

```
# функция с переменным числом аргументов. оба варианта одновременно:

def f(*args, **kwargs):
    print(args)
    print(kwargs)

print(f(1, 2, 3, fourth=4, fifth=5))
# (1, 2, 3)
# {’fifth’: 5, ’fourth’: 4}
```

## Подмножество языка для функционального программирования

### Иммутабельность данных

### Функции как объекты 1-го класса
Все объекты в языке Python могут быть отнесены к объектам первого класса. Это означает, что все объекты, имеющие идентификатор, имеют одинаковый статус. Это также означает, что все объекты, имеющие идентификатор, можно интерпретировать как данные. Функции, в том числе, являются объектами первого класса. Это означает, что язык поддерживает передачу функций в качестве аргументов другим функциям, возврат их как результат других функций, присваивание их переменным или сохранение в структурах данных.
#### Анонимные функции
Функции могут быть также созданы в форме лямбда-выражения: _lambda arg1, arg2, ... : expr_. В этой форме создаётся новый объект функции, который возвращается для вызова в дальнейшем вместо присваивания по имени. Каждый аргумент argi оказывается таким же, как и в операторе _def_, а _expr_ - возвращаемым значением при вызовах. Выполнение кода в _expr_ откладывается до момента вызова. Пример:
```
myabs = lambda x: -x if x < 0 else x

print(myabs(-100)) # 100
print(myabs(100)) # 100
```
#### Функции высшего порядка
Как было сказано выше, функции можно передавать в качестве аргументов или возвращать в качестве результата. Пример:
```
def f(x):
    return x + 3

def g(func, x):
    return func(x) * func(x)

print(g(f, 7)) # 100
```

```
print(list(map(abs, [-1, -2, -3, -4]))) # [1, 2, 3, 4]

print(list(filter(lambda x: x % 2 != 0, [1, 2, 3, 4]))) # [1, 3]

print([x ** 3 for x in range(10)]) # [0, 1, 8, 27, 64, 125, 216, 343, 512, 729]
```

#### Встроенные функции высших порядков для работы с последовательностями
1. ***apply(f, \*args[, \*\*kwargs])*** применяет функцию, переданную в качестве первого аргумента, к параметрам, которые переданы вторым и третьим аргументом. 
2. ***range(i,j [,stride])*** (см. пункт циклы и итерации)
3. ***map(f, *args)*** используется для применения некоторой функции ко всем элементам последовательности. Первый параметр - функция, которая будет применяться ко всем элементам. каждый следующий n + 1 - й параметр должен быть последовательностью, т. к. каждый его элемент будет исполльзован в качестве n-го параметра при вызове функции f(). Результатом будет список, составленный из результатов выполнения этой функции.
4. ***filter(f, iterable, ...)*** принимает функцию с условием и последовательность, из которой берутся значения. В результирующую последовательность попадут только те значения из исходной, для которой f() возвратит истину
5. ***sum(iterable,/,start=0)*** получает сумму элементов. Пример: ```sum(rage(10)) # 45```
6. ***reduce(f, iterable,/,start=0)*** применяется для организации цепочечных вычислений (вычислений с накоплением результата, свёртка). Вот как выглядит реализация функции ***sum*** с помощью ***reduce***: 
```
def sum(lst, start):
    return reduce(lambda x, y: x + y, lst, start)
```
7. ***sorted(iterable, \*, key=None, reverse=False)*** возвращает отсортированный лист iterable.

#### Остальные функции: https://docs.python.org/3/library/functions.html
